//! Vulnerability and scan result types.

use serde::{Deserialize, Serialize};

/// Severity level of a security vulnerability.
///
/// Based on CVSS scoring thresholds:
/// - Critical: 9.0 - 10.0
/// - High: 7.0 - 8.9
/// - Medium: 4.0 - 6.9
/// - Low: 0.1 - 3.9
/// - Unknown: No score available
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    /// Critical severity (CVSS 9.0+)
    Critical,
    /// High severity (CVSS 7.0-8.9)
    High,
    /// Medium severity (CVSS 4.0-6.9)
    Medium,
    /// Low severity (CVSS 0.1-3.9)
    Low,
    /// Severity could not be determined
    Unknown,
}

impl Severity {
    /// Returns the uppercase string representation of the severity.
    ///
    /// # Example
    ///
    /// ```
    /// use extenscan::model::Severity;
    ///
    /// assert_eq!(Severity::Critical.as_str(), "CRITICAL");
    /// assert_eq!(Severity::Low.as_str(), "LOW");
    /// ```
    pub fn as_str(&self) -> &'static str {
        match self {
            Severity::Critical => "CRITICAL",
            Severity::High => "HIGH",
            Severity::Medium => "MEDIUM",
            Severity::Low => "LOW",
            Severity::Unknown => "UNKNOWN",
        }
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// A security vulnerability affecting a package.
///
/// Contains information about a known vulnerability including its
/// identifier, severity, and remediation details.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Vulnerability identifier (e.g., CVE-2021-44228, GHSA-xxxx).
    pub id: String,

    /// ID of the affected package.
    pub package_id: String,

    /// Severity level of the vulnerability.
    pub severity: Severity,

    /// Brief title or summary of the vulnerability.
    pub title: String,

    /// Detailed description of the vulnerability.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Version that contains the fix, if available.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fixed_version: Option<String>,

    /// URL to more information about the vulnerability.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reference_url: Option<String>,
}

/// Information about an outdated package.
///
/// Indicates that a newer version is available for a package.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutdatedInfo {
    /// ID of the outdated package.
    pub package_id: String,

    /// Currently installed version.
    pub current_version: String,

    /// Latest available version.
    pub latest_version: String,
}

/// Complete results from a scan operation.
///
/// Contains all discovered packages, any vulnerabilities found,
/// and information about outdated packages.
///
/// # Example
///
/// ```
/// use extenscan::{Package, ScanResult, Source};
///
/// let packages = vec![
///     Package::new("lodash", "lodash", "4.17.21", Source::Npm),
/// ];
///
/// let result = ScanResult::new(packages);
/// assert_eq!(result.packages.len(), 1);
/// assert!(result.vulnerabilities.is_empty());
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// All packages discovered during the scan.
    pub packages: Vec<super::Package>,

    /// Security vulnerabilities found in the packages.
    pub vulnerabilities: Vec<Vulnerability>,

    /// Packages with newer versions available.
    pub outdated: Vec<OutdatedInfo>,

    /// Timestamp when the scan was completed.
    pub scan_time: chrono::DateTime<chrono::Utc>,
}

impl ScanResult {
    /// Creates a new scan result with the given packages.
    ///
    /// The vulnerabilities and outdated lists are initialized as empty,
    /// and the scan time is set to the current UTC time.
    ///
    /// # Arguments
    ///
    /// * `packages` - The packages discovered during scanning
    pub fn new(packages: Vec<super::Package>) -> Self {
        Self {
            packages,
            vulnerabilities: Vec::new(),
            outdated: Vec::new(),
            scan_time: chrono::Utc::now(),
        }
    }

    /// Returns the number of critical vulnerabilities.
    pub fn critical_count(&self) -> usize {
        self.vulnerabilities
            .iter()
            .filter(|v| v.severity == Severity::Critical)
            .count()
    }

    /// Returns the number of high severity vulnerabilities.
    pub fn high_count(&self) -> usize {
        self.vulnerabilities
            .iter()
            .filter(|v| v.severity == Severity::High)
            .count()
    }

    /// Returns true if any critical or high severity vulnerabilities were found.
    pub fn has_severe_vulnerabilities(&self) -> bool {
        self.critical_count() > 0 || self.high_count() > 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::{Package, Source};

    fn create_test_vulnerability(id: &str, severity: Severity) -> Vulnerability {
        Vulnerability {
            id: id.to_string(),
            package_id: "test-pkg".to_string(),
            severity,
            title: "Test vulnerability".to_string(),
            description: None,
            fixed_version: None,
            reference_url: None,
        }
    }

    #[test]
    fn test_severity_as_str() {
        assert_eq!(Severity::Critical.as_str(), "CRITICAL");
        assert_eq!(Severity::High.as_str(), "HIGH");
        assert_eq!(Severity::Medium.as_str(), "MEDIUM");
        assert_eq!(Severity::Low.as_str(), "LOW");
        assert_eq!(Severity::Unknown.as_str(), "UNKNOWN");
    }

    #[test]
    fn test_severity_display() {
        assert_eq!(format!("{}", Severity::Critical), "CRITICAL");
        assert_eq!(format!("{}", Severity::Low), "LOW");
    }

    #[test]
    fn test_scan_result_new() {
        let packages = vec![Package::new("pkg", "Package", "1.0.0", Source::Npm)];
        let result = ScanResult::new(packages);

        assert_eq!(result.packages.len(), 1);
        assert!(result.vulnerabilities.is_empty());
        assert!(result.outdated.is_empty());
    }

    #[test]
    fn test_scan_result_critical_count() {
        let packages = vec![Package::new("pkg", "Package", "1.0.0", Source::Npm)];
        let mut result = ScanResult::new(packages);

        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-1", Severity::Critical));
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-2", Severity::Critical));
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-3", Severity::High));

        assert_eq!(result.critical_count(), 2);
    }

    #[test]
    fn test_scan_result_high_count() {
        let packages = vec![Package::new("pkg", "Package", "1.0.0", Source::Npm)];
        let mut result = ScanResult::new(packages);

        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-1", Severity::High));
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-2", Severity::High));
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-3", Severity::Medium));

        assert_eq!(result.high_count(), 2);
    }

    #[test]
    fn test_scan_result_has_severe_vulnerabilities() {
        let packages = vec![Package::new("pkg", "Package", "1.0.0", Source::Npm)];
        let mut result = ScanResult::new(packages.clone());

        // No vulnerabilities
        assert!(!result.has_severe_vulnerabilities());

        // Add medium - still not severe
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-1", Severity::Medium));
        assert!(!result.has_severe_vulnerabilities());

        // Add high - now severe
        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-2", Severity::High));
        assert!(result.has_severe_vulnerabilities());
    }

    #[test]
    fn test_scan_result_has_severe_with_critical() {
        let packages = vec![Package::new("pkg", "Package", "1.0.0", Source::Npm)];
        let mut result = ScanResult::new(packages);

        result
            .vulnerabilities
            .push(create_test_vulnerability("CVE-1", Severity::Critical));
        assert!(result.has_severe_vulnerabilities());
    }

    #[test]
    fn test_outdated_info() {
        let info = OutdatedInfo {
            package_id: "lodash".to_string(),
            current_version: "4.17.20".to_string(),
            latest_version: "4.17.21".to_string(),
        };

        assert_eq!(info.package_id, "lodash");
        assert_eq!(info.current_version, "4.17.20");
        assert_eq!(info.latest_version, "4.17.21");
    }

    #[test]
    fn test_vulnerability_serialization() {
        let vuln = create_test_vulnerability("CVE-2024-1234", Severity::High);
        let json = serde_json::to_string(&vuln).unwrap();

        assert!(json.contains("\"id\":\"CVE-2024-1234\""));
        assert!(json.contains("\"severity\":\"high\""));

        let deserialized: Vulnerability = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.id, "CVE-2024-1234");
        assert_eq!(deserialized.severity, Severity::High);
    }
}
